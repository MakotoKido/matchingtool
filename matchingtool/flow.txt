・前提
とりあえず勝ち数+ランダムのマッチング
順位は勝ち数+OMWで出す
勝ち点はとりあえずなしで
同じ人は絶対マッチングしない
CSVで読み込み、バックアップを行う
結果報告は主催が受けて登録する

Javaで書こうかと思ったけどGUIの実装と毎回parseintすることを考えたらScriptが圧倒的に楽そうなので適宜変えつつやる
変数考えるのが楽なんじゃあ〜
ファイル読み込みもHTMLからいけて楽なんじゃあ

・[{id:num, name:String, win:num, lose:num, draw:num, opponents: [ids]}]で参加者の値を保持する(参加者情報をいじるメソッドではそれを返す)
→最低限保持してなきゃいけない値を保持　計算で出せるものは計算をかける
連想配列じゃなくてオブジェクトらしい

OWM%はtofixedで固定小数点とかもはや×100で扱うと何かと使い勝手が良さそう
10ラウンドまでと考えると精度は小数点以下4桁くらいで良さそうだが

全体の流れ
参加者をCSVに登録
読み込み
1回戦目(もしくはコンティニューポイント)のマッチング

1.登録の流れ
CSV(参加者名のみ)インポート
↓
不戦勝処理用のid=0はマッチング防止用にリストに入れない
id = 1;
各参加者ごとにid,参加者名,勝ち数(以降デフォ0),負け数,引き分け,対戦相手の番号([])のキーと値をセット
↓
id++;

(参加者なくなるまでくりかえし)
end


2.マッチング
・(勝ち数、勝ち点、完全ランダム、OMWあたり何を優先してマッチングを行うのか選択させたい)デフォは同じ勝ち数の中でランダム
・今までのマッチングデータを参照し、同じ参加者とマッチングはさせない(アラート出してマッチングさせられる機能があればいいがとりあえずなしで)

配列をシャッフル
↓
勝順で並べる
Array.sort(function (a,b){
if(a.win>b.win) return 1のやつ
return-1
return 0
}
↓
要素を0から順に2つずつとり、matching[[]]に　卓番、2者のid、結果(デフォ=null)　を格納
その際に、相手(インデックス奇数側のみで十分)のopponents []を参照し、自身のIDがないかチェック
あれば次の要素と入れ替える(妥当性要検討、たぶん大丈夫)
要素が取れたら残りの次の要素を組みに行く
参加者が奇数なら一番最後に残った要素(全敗中の1組)は不戦勝用のid=0と組ませる

(不戦勝はあらかじめ勝敗結果を登録したい)
↓
対戦表(卓番、ID、名前、結果(入力されるまで未と表示)、結果登録ボタン
最上部と最下部に結果確定ボタン(全卓報告があるまで押せない)を出力
end

3.結果入力
対戦表にそれぞれ結果報告用ボタン表示
テーブルidを参照(引数this.idで取得可能)
クリック
↓
入力
//ここらへんから
入力された勝敗は一旦対戦の配列にくっつけて格納する(対戦表の画面で結果表示をしやすいように)
入力しましたアラート(n番勝ち、m番負け　上記の内容で登録しました)
↓
確定まで書き換え可能なようにする
書き込みのフラグはhtmlのvalue に立てておくか、データに書き込む
↓
すべて終わったら確定ボタンを有効化
チェッカーは毎回の入力ごとに発動させる

4.次のマッチング前
結果確定ボタン有効化
↓
登録内容確認
↓
確定or戻る(結果入力画面)
↓
結果を参加者の配列に格納
↓
○回戦の結果を確定しました
↓
マッチング画面へ


5.次のマッチング
2.の手順と同じ(必要があれば、できればオプションボタンをつける)


6.ランキング表示(常にヘッダー上あたりにリンクを貼っておく)
確定しているラウンドまでの結果(=参加者listに登録されている結果)から、勝ち数→OMW%の順に表示

OMW%の算出
Omw
oppsの配列foreach

7.バックアップ生成
ラウンド間データ

マッチング確定後データ

8.バックアップ読み込み
同じ配列になるようフォーマットを作って読み込む